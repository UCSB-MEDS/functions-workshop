---
title: "Untitled"
format: html
editor: visual
---

## Version 4

#### **Primary Goal:** allow users to select which temperature measurements to include in the cleaned data frame

Our function works perfectly fine as is, but let's say we don't always want all three temperature measurements (surface temperature (`Temp_top`), mid-column temperature (`Temp_mid`), and bottom temperature (`Temp_top`)) included in our cleaned data. We can build flexibility into our function by adding an argument that allows the user to select exactly which of the three temperature measurements to include in the resulting cleaned data frame. To do this, we'll:

1.  add an argument called `include_temps`, which defaults to including all three temperature variables
2.  create a vector of variable names to `select` in our cleaning pipeline; recall that the raw data frame includes 87 variables -- our cleaning pipeline starts by selecting just the few we care about, however, that `select` call must now be made flexible enough to accept some or all temperature variables based on user inputs (`r fontawesome::fa("book-open-reader", fill = "#5A5A5A", a11y = "sem")` I first got an error message when attempting to `select(all_cols)`, since an external vector alone can't be used to make `select`ions; I then referenced this [resource](https://tidyselect.r-lib.org/reference/all_of.html))
3.  make our last `select` call, which is used to reorder columns, flexible enough to reorder temperature variables which may or may not be present (`r fontawesome::fa("book-open-reader", fill = "#5A5A5A", a11y = "sem")` I again referenced this [resource](https://tidyselect.r-lib.org/reference/all_of.html))
```{r}
#| eval: false
#| echo: true
#| message: false
#| warning: false
#| code-annotations: hover
clean_ocean_temps <- function(raw_data, include_temps = c("Temp_top", "Temp_mid", "Temp_bot")){ # <1>
  
  # load dependencies ----
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(chron)
  library(naniar)
  
  # get site name as character string from object (raw_data) name ----
  site_name <- deparse(substitute(raw_data)) 
  site_name <- paste(str_to_title(site_name), "Reef") 
  
  # columns to select ---- 
  always_selected_cols <- c("year", "month", "day", "decimal_time") # <2>
  all_cols <- append(always_selected_cols, include_temps) # <2>
  
  # clean data ----
  temps_clean <- raw_data |> 
    select(all_of(all_cols)) |> # 2
    filter(year %in% c(2005:2020)) |> 
    mutate(site = rep(site_name)) |> 
    unite(col = date, year, month, day, sep = "-", remove = FALSE) |> 
    mutate(time = times(decimal_time)) |> 
    unite(col = date_time, date, time, sep = " ", remove = TRUE) |> 
    mutate(date_time = as.POSIXct(date_time, "%Y-%m-%d %H:%M:%S", tz = "GMT"),
           year = as.factor(year),
           month = as.factor(month),
           day = as.numeric(day)) |>
    mutate(month_name = as.factor(month.name[month])) |>
    replace_with_na(replace = list(Temp_bot = 9999, Temp_top = 9999, Temp_mid = 9999)) |> 
    select(any_of(c("site", "date_time", "year", "month", "day", "month_name", "Temp_bot", "Temp_mid", "Temp_top"))) # <3>
  
  # return cleaned df ----
  return(temps_clean) 
}
```
1. add a second argument called `include_temps` with default values `Temp_top`, `Temp_mid`, and `Temp_bot`
2. create a vector of variables to `select` from the raw data, based on user-specified temperature variables in `include_temps`
3. make this `select` flexible enough to reorder temperature variables which may or may not be present, depending on what the user specifies in the `include_temps` argument